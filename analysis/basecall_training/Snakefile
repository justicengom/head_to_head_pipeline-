from pathlib import Path
import os
from typing import Dict, Set, Union

from snakemake.utils import min_version

min_version("5.10.0")

GB = 1_024
PathLike = Union[str, Path, os.PathLike]

# ======================================================
# Config files
# ======================================================
configfile: "config.yaml"
containers: Dict[str, PathLike] = config["containers"]
envs: Dict[str, PathLike] = config["envs"]
assemblies: Dict[str, PathLike] = config["assemblies"]
fast5: Dict = config["fast5"]
fast5["outdir"] = Path(fast5["outdir"])
fast5["indir"] = Path(fast5["indir"])
samples: Set[str] = {*assemblies.keys()}

# ======================================================
# Global functions and variables
# ======================================================
outdir = Path(config["outdir"])
data_dir = Path(config["data_dir"])
mada_dir = data_dir / "madagascar"
ont_dir = mada_dir / "nanopore"

output_files = set()

for sample in samples:
    output_files.add(outdir / f"{sample}" / f"{sample}.read_references.fasta")
    output_files.add(fast5["outdir"] / "filename_mapping.txt")

# ======================================================
# Rules
# ======================================================
rule all:
    input: output_files

# https://github.com/nanoporetech/taiyaki/blob/master/docs/walkthrough.rst#bam-of-mapped-basecalls
rule map_basecalls:
    input:
        reads=ont_dir / "{sample}" / "{sample}.nanopore.fastq.gz",
        assembly=lambda wildcards: assemblies[wildcards.sample],
    output:
        bam=outdir / "{sample}" / "mapping" / "{sample}.basecalls_mapped_to_asm.bam"
    shadow: "shallow"
    threads: 8
    resources:
        mem_mb=lambda wildcards, attempt: (4 * GB) * attempt
    singularity: containers["conda"]
    conda: envs["aln_tools"]
    params:
        preset="map-ont",
        minimap_extras=" ".join([
            "--secondary=no",  # don't output secondary alignments
            "-a",  # output SAM
            "-L",  # Write CIGAR with >65535 operators at the CG tag
            "--sam-hit-only",  # don't output unmapped reads
        ]),
        samtools_extras=" ".join([
            "-b",  # output BAM
        ]),
    shell:
        """
        minimap2 -x {params.preset} \
            {params.minimap_extras} \
            -t {threads} \
            {input.assembly} \
            {input.reads} | \
        samtools view {params.samtools_extras} -T {input.assembly} -o {output.bam}
        """

# https://github.com/nanoporetech/taiyaki/blob/master/docs/walkthrough.rst#extract-per-read-references
rule extract_per_read_references:
    input:
        assembly=lambda wildcards: assemblies[wildcards.sample],
        bam=rules.map_basecalls.output.bam
    output:
        read_references=outdir / "{sample}" / "{sample}.read_references.fasta"
    params:
        min_covg=config["min_covg"],
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: int(0.5 * GB) * attempt
    singularity: containers["taiyaki"]
    shell:
        """
        get_refs_from_sam.py --min_coverage {params.min_covg} \
            {input.assembly} \
            {input.bam} > {output.read_references}
        """

rule aggregate_read_references:
    input:
        read_references=[
            outdir / f"{sample}" / f"{sample}.read_references.fasta"
            for sample in samples
        ],
    output:
        read_references=outdir / "read_references.fasta",
    threads: 1
    resources:
        mem_mb=lambda wildcards, attempt: int(0.5 * GB) * attempt
    shell:
        """
        awk 1 {input.read_references} > {output.read_references}
        """

rule extract_read_ids:
    input:
        read_references=rules.aggregate_read_references.output.read_references,
    output:
        read_ids=outdir / "read_ids.txt",
    threads: 1
    resources:
        mem_mb=int(0.3 * GB)
    params:
        pattern="'^>(?P<id>[\w-]+)\s*$'",
        replace_with="'$id'",
        extras="-uuu --no-line-number",  # disable smart filtering with -uuu
    shell:
        """
        rg --only-matching {params.pattern} --replace {params.replace_with} {params.extras} {input.read_references} > {output.read_ids}
        """

rule extract_fast5s_for_training:
    input:
        read_ids=rules.extract_read_ids.output.read_ids,
    output:
        success=fast5["outdir"] / "filename_mapping.txt",
    threads: 32
    resources:
        mem_mb=lambda wildcards, attempt: attempt * (16 * GB)
    singularity: containers["fast5"]
    params:
        indir=fast5["indir"],
        save_path=fast5["outdir"],
        batch_size=fast5["batch_size"],
        extras="--recursive"
    shell:
        """
        fast5_subset --input {params.indir} \
            --save_path {params.save_path} \
            --read_id_list {input.read_ids} \
            --batch_size {params.batch_size} \
            --threads {threads} \
            {params.extras}
        touch {output.success}
        """
